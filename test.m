close all;
clear all;clc;
format long;
%%逆动力学
deg = pi/180;

L1= Revolute('d', 0, 'a', 0, 'alpha', 0,'modified', ...
    'I', [0.1183 -0.0001 0.0001;
          -0.0001 0.1182 0.0001;
          0.0001 0.0001 0.0140], ...
    'r', [0.0002 0.0002 0.1264], ...
    'm', 5.6431, ...
    'Jm', 0, ...
    'G', 0, ...
    'B', 0, ...
    'Tc', [0 0], ...
    'qlim', [-360 360]*deg );

L2 = Revolute('d', 0, 'a', 0.040, 'alpha', -pi/2, 'offset', -pi/2,'modified', ...
    'I', [0.0723,0.0000,-0.0051;0.0000,0.0784,0.0000;-0.0051,0.0000,0.0169;], ...
    'r', [-0.0062,0.0001,0.1080], ...
    'm', 5.0478, ...
    'Jm', 0, ...
    'G', 0, ...
    'B', 0, ...
    'Tc', [0 0], ...
    'qlim', [-360 360]*deg );
L3 = Revolute('d', 0, 'a', 0.275, 'alpha', 0, 'modified', ...
    'I', [0.4263,0.0000,-0.0072;
        0.0000,0.4334,0.0001;
        -0.0072,0.0001,0.0191], ...
    'r', [-0.0131,0.0001,0.2402], ...
    'm', 5.7542, ...
    'Jm', 0, ...
    'G', 0, ...
    'B', 0, ...
    'Tc', [0, 0], ...
    'qlim', [-360 360]*deg );

L4 = Revolute('d', 0.280, 'a', 0.025, 'alpha', -pi/2, 'modified', ...
    'I', [0.0821,0.0000,-0.0314;0.0000,0.1257,0.0001;-0.0314,0.0001,0.0451], ...
    'r', [-0.0850,0.0003,0.1540], ...
    'm', 3.0870, ...
    'Jm', 0, ...
    'G', 0, ...
    'B', 0, ...
    'Tc', [0, 0], ...
    'qlim', [-360 360]*deg);
L5 = Revolute('d', 0, 'a', 0, 'alpha', pi/2, 'modified', ...
    'I', [0.0235,0.0000,-0.0002;0.0000,0.0253,0.0000;-0.0002,0.0000,0.0045], ...
    'r', [0.0001,0.0002,0.0982], ...
    'm', 2.0459, ...
    'Jm', 0, ...
    'G', 0, ...
    'B', 0, ...
    'Tc', [0, 0], ...
    'qlim', [-360 360]*deg );
L6 = Revolute('d', 0, 'a', 0, 'alpha', -pi/2, 'modified', ...
    'I', [0.0684,0.0000,0.0001;0.0000,0.0696,-0.0001;0.0001,-0.0001,0.0047], ...
    'r', [-0.0111,-0.0003,0.1366], ...
    'm', 2.6317, ...
    'Jm', 0, ...
    'G', 0, ...
    'B', 0, ...
    'Tc', [0, 0], ...
    'qlim', [-360 360]*deg );
robot=SerialLink([L1,L2,L3,L4,L5,L6],'name','ROKAE','comment','LL');  %SerialLink类函数
% robot.display();    %Link类函数，显示建立机器人DH参数
theta1=[0 0 0 0 0 0];    %机器人伸直且垂直
% robot.plot(theta1);  %SerialLink类函数,显示机器人图像
theta2=[-pi/7 pi/2 -pi/6 pi/5 pi/2 pi/3];
t=[0:0.01:2];
g=jtraj(theta1,theta2,t);
[q,qd,qdd]=jtraj(theta1,theta2,t);
Q = robot.rne(q,qd,qdd);

%% 
m = [5.6431, 5.0478, 5.7542, 3.0870, 2.0459, 2.6317 ];

I_c(:,:,1) = [0.1183, -0.0001, 0.0001; -0.0001, 0.1182, 0.0001; 0.0001, 0.0001, 0.0140];
I_c(:,:,2) = [0.0723, 0.0000, -0.0051; 0.0000, 0.0784, 0.0000; -0.0051, 0.0000, 0.0169];
I_c(:,:,3) = [0.4263, 0.0000, -0.0072; 0.0000, 0.4334, 0.0001; -0.0072, 0.0001, 0.0191];
I_c(:,:,4) = [0.0821, 0.0000, -0.0314; 0.0000, 0.1257, 0.0001; -0.0314, 0.0001, 0.0451];
I_c(:,:,5) = [0.0235, 0.0000, -0.0002; 0.0000, 0.0253, 0.0000; -0.0002, 0.0000, 0.0045];
I_c(:,:,6) = [0.0684, 0.0000, 0.0001; 0.0000, 0.0696, -0.0001; 0.0001, -0.0001, 0.0047];

P_c(1,:) = [0.0002, 0.0002, 0.1264];
P_c(2,:) = [-0.0062, 0.0001, 0.1080];
P_c(3,:) = [-0.0131, 0.0001, 0.2402];
P_c(4,:) = [-0.0850, 0.0003, 0.1540];
P_c(5,:) = [0.0001, 0.0002, 0.0982];
P_c(6,:) = [-0.0111, -0.0003, 0.1366];

%惯性矩在连杆坐标系
I_p = zeros(3,3,6);
I_para = zeros(6,6);
I = [1 0 0;
     0 1 0;
     0 0 1];
for i=1:6
    I_p(:,:,i) = I_c(:,:,i) + m(i) * (P_c(i,:) * P_c(i,:).' * I - P_c(i,:).' * P_c(i,:));
    I_para(1,i) = I_p(1,1,i);
    I_para(2,i) = -I_p(1,2,i);
    I_para(3,i) = -I_p(1,3,i);
    I_para(4,i) = I_p(2,2,i);
    I_para(5,i) = -I_p(2,3,i);
    I_para(6,i) = I_p(3,3,i);
end
dof = 6;
numParam = 12;
fc = zeros(1,dof);
fv = zeros(1,dof);
P = zeros(72,1);
for i = 1:dof
    tmp = numParam*(i-1);
    P(tmp+10) = m(i);
    P(tmp+11) = fc(i);
    P(tmp+12) = fv(i);
    P(tmp+7:tmp+9) = P_c(i,:);
    P(tmp+1:tmp+6) = I_para(:,i);
end

%%
g = 9.81;
for i=1:size(q,1)
    torque(i,:) = NewtonEular(g, q(i,:), qd(i,:), qdd(i,:) ,P);
%     torque(i,:) = Force_iteration( q(i,:), qd(i,:), qdd(i,:) );
end
% for i=1:size(q,1)
%     torque(i,:) = parameters( q(i,:), qd(i,:), qdd(i,:) ) * parameters_real();
% end
figure
i=1:6;
% subplot(2,3,1);
% robot.plot(g)%绘制动画
subplot(2,3,2);
qplot(q(:,i));grid on;title('位置');%绘制每个关节位置
subplot(2,3,3);
qplot(qd(:,i));grid on;title('速度');%绘制每个关节速度
subplot(2,3,4);
qplot(qdd(:,i));grid on;title('加速度');%绘制每个关节加速度
Q = robot.rne(q,qd,qdd);%获得每个时间点所需要的关节力矩
subplot(2,3,5);
qplot(t,Q);grid on;title('Q');%绘制每个关节的力矩
subplot(2,3,6);
qplot(t,torque);grid on;title('torque');%绘制每个关节的力矩
error = torque - Q;
figure
qplot(error);


% T = zeros(4,4,size(q,1));
% P_c = zeros(6,3);
% for i=1:size(q,1)
%     T(:,:,i) = robot.fkine(q(i,:));
%     T1 = T(:,:,i);
%     R1 = T1(1:3,1:3);
%     P(:,i) = T1(1:3,4);
%     [ W, V, Ang_acc, acc, acc_c ] = Velocity_iteration(  P_c, q(i,:), qd(i,:), qdd(i,:) );
%     Pv(:,i) = R1 * V(:,7);
%     Pacc(:,i) = R1 * acc(:,7);
% end
% for i=1:size(q,1)-3
%      Pd(:,i) = (P(:,i)-4*P(:,i+1)+3*P(:,i+2))/0.02;
%     Pdd(:,i) = (2*P(:,i+3)-5*P(:,i+2)+4*P(:,i+1)-P(:,i))/0.0001;
% end
% 
% for i=1:size(Pdd,2)
%     error(:,i) = Pacc(:,i+3) - Pdd(:,i);
% end
% figure
% qplot(error);

